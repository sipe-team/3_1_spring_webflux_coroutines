# 4주차

### Continuation

중단이 가능해야되는 suspend 함수를 동작시키기 위해 필요한 객체.

**코루틴의 실행 및 중단과 관련된 핵심적인 역할을 수행**함.

suspendable한 함수가 중단 된 다음에, 재개할 때 사용하게 되는 resumeWith()를 제공함.

```kotlin
public interface Continuation<in T> {
    public abstract val context: kotlin.coroutines.CoroutineContext

    public abstract fun resumeWith(result: kotlin.Result<T>): kotlin.Unit
}
```

suspend 함수가 COROUTINE_SUSPENDED를 반환하여 suspension point를 생성하고, `Continuation.resumeWith()`를 호출해서 coroutine을 재개하게 됨

주로 코루틴 빌더나 디스패처가 호출하게 됨.

### CoroutineContext

### CoroutineScope

### Dispatchers

코루틴은 어쨌든 실행되려면 스레드 위에 올라가 있어야 하는데,

이 때 코루틴을 어떤 스레드에서 실행할지를 정하는 것이 CoroutineDispatcher임

![image.png](./res/image.png)

유저가 코루틴을 생성한 후 CoroutineDispatcher에게 보내면

![image.png](./res/image%20(1).png)

CoroutineDispatcher는 스레드풀에서, 현재 사용할 수 있는 스레드에 해당 코루틴을 보냄

![image.png](./res/image%20(2).png)


스레드는 해당 코루틴을 수행함

**코틀린 Dispatcher 종류들**

```kotlin
public object Dispatchers {
    // CPU를 많이 사용하는 작업을 실행하기 위한 디스패처
    // JVM의 공유 스레드풀을 사용하고, 사용 가능한 스레드의 최대 수는 CPU의 코어 수와 같음
    @kotlin.jvm.JvmStatic public final val Default: kotlinx.coroutines.CoroutineDispatcher /* compiled code */

    // 디스크 또는 네트워크 I/O 작업을 실행하는데 최적화 되어 있는 디스패처
    // 필요에 따라 추가적으로 스레드를 더 생성/줄이기 가능, **최대 64개**까지 생성 가능
    // Default 디스패처와 스레드를 공유함
    @kotlin.jvm.JvmStatic public final val IO: kotlinx.coroutines.CoroutineDispatcher /* compiled code */

    // UI와 상호작용을 위한 디스패처 ( coroutine-android 라이브러리에 대한 의존성이 있어야 사용 가능 )
    @kotlin.jvm.JvmStatic public final val Main: kotlinx.coroutines.MainCoroutineDispatcher /* compiled code */
        public final get

    @kotlin.jvm.JvmStatic public final val Unconfined: kotlinx.coroutines.CoroutineDispatcher /* compiled code */
}
```

launch 와 같은 Coroutine Builder에 Dispatcher를 인자로 넘겨서, Context/Dispatcher 지정 가능

```kotlin
fun main() = runBlocking<Unit> {
    launch {   
        // 인자를 안 넘겨주면 상위 **CoroutineScope**로 부터 context 상속 받음 -> main 스레드에서 실행
        println("main runBlocking       : 나는 ${Thread.currentThread().name} 에서 돌아")
    }
    launch(Dispatchers.Unconfined) {  
        // Context를 지정하지 않겠다는 의미.
        // 해당 코루틴을 호출한 스레드에서 실행함
        // 중단점 이후 다시 재개될 때는, 재개가 호출된 스레드에서 실행됨.
        println("Unconfined             : 나는 ${Thread.currentThread().name} 에서 돌아")
    }
    launch(Dispatchers.Default) {  
        // DefaultDispatchers 등록
        println("Default                : 나는 ${Thread.currentThread().name} 에서 돌아")
    }
    launch(newSingleThreadContext("H43RO_Thread")) {  
        // 새로운 쓰레드 생성
        println("newSingleThreadContext : 나는 ${Thread.currentThread().name} 에서 돌아")
    }
}

```

```kotlin
Unconfined             : 나는 main 에서 돌아
Default                : 나는 DefaultDispatcher-worker-1 에서 돌아
newSingleThreadContext : 나는 H43RO_Thread 에서 돌아
main runBlocking       : 나는 main 에서 돌아

```

Dispatchers.Unconfined

```kotlin
fun main() = runBlocking<Unit> {
    launch(Dispatchers.Unconfined) {
        println("Unconfined             : 나는 ${Thread.currentThread().name} 에서 돌아")
        delay(500)
        println("Unconfined             : 딜레이 이후에는 ${Thread.currentThread().name} 에서 돌아")
    }
    launch {
        println("main runBlocking       : 나는 ${Thread.currentThread().name} 에서 돌아")
        delay(1000)
        println("main runBlocking       : 딜레이 이후에는 ${Thread.currentThread().name} 에서 돌아")
    }
}
```

```kotlin
Unconfined             : 나는 main 에서 돌아
main runBlocking       : 나는 main 에서 돌아
Unconfined             : 딜레이 이후에는 kotlinx.coroutines.DefaultExecutor 에서 돌아
main runBlocking       : 딜레이 이후에는 main 에서 돌아
```

Dispatcher가 설정되지 않아서, 상위로부터 스레드를 상속받은 코루틴은,
중단 지점과 상관 없이 상속받은 설정에 해당하는 스레드에서 실행함

Dispatchers.Unconfined를 디스패처로 채택하면, 해당 코루틴을 호출한 스레드를 상속받기 때문에, 중단점 이후에는 다른 스레드에서 동작할 수 있음

→ 위 결과를 보면 delay() 함수를 kotlinx.coroutines.DefaultExecutor에서 호출한 것을 알 수 있음.

이전 스레드를 그대로 이용하기 때문에 context switching 비용이 줄어듦, 빠름

하지만 어떤 스레드에서 실행될지 예상할 수 없기 때문에 스레드에 민감한 동작 (like 안드로이드 UI 그리기) 을 할 때는 위험함

### async

### launch

### suspend

### yeild

### runBlocking

### withContext