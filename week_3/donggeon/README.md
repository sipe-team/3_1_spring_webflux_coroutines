# 3주차 진행

### 목차
- 코루틴 개념, 코루틴을 왜 쓰는가? - 10분
  - 코루틴 개념
  - 코루틴 docs

- 코루틴의 동작원리, 스레드와의 차이 - 10분

- 간단 실습? - 10분
  - api 하나 만드는데, io작업 3개 이상이 있다.
  - 3개를 동시에 실행시키고, 동시에 완료된 이후에 return하도록 코루틴을 기반으로 구성.
  - 하나는 스레드 기반으로 해보기~

### 코루틴 개념, 코루틴을 왜 쓰는가? - 10분

- 적은 리소스에서 다양한 IO 작업들을 처리하기 위해
- 비용 최적화
- Webflux와는 다른 가독성
  - 코드 유지보수에 매우 탁월 

### 동작원리
1. **상태 머신 기반 실행**:
   - 코루틴은 상태 머신(State Machine)으로 동작합니다.  
     - 각 코루틴은 **현재 실행 상태(중단점)**를 저장합니다.
     - 실행이 중단되면 상태를 기록하고 다른 코루틴을 실행.
   - 스택이나 OS 수준의 스케줄링이 필요하지 않음.

2. **비차단 방식**:
   - 스레드는 자원을 기다릴 때 차단(block) 상태로 전환되지만, 코루틴은 **일시 중단(suspend)** 상태가 되며 스레드 풀의 다른 작업을 실행 가능.
   - 예: 네트워크 요청 시, 해당 코루틴은 중단되지만 동일한 스레드는 다른 작업을 처리.

3. **디스패처를 통한 스케줄링**:
   - 디스패처(Dispatcher)가 코루틴 실행을 제어하며, 실행 가능한 코루틴을 스레드 풀에 배치.
   - 스케줄링이 협력적(cooperative) 방식으로 이루어지므로, 오버헤드가 적음.

4. **구조화된 동시성**:
   - 부모-자식 관계에서 모든 코루틴이 **단일 스코프**로 묶여 동작.
   - 부모 작업이 완료되거나 취소되면, 모든 자식 코루틴도 중단되어 리소스 누수를 방지.

### 코루틴의 동작원리, 스레드와의 차이 - 10분

- 전통적인 스레드 방식의 병렬 처리 방식
  - 각 스레드는 독립적인 실행 단위로서, 자신만의 스택과 레지스터를 가지고 실행
  - 병렬 처리를 위해 CPU의 멀티코어를 활용하여 동시에 여러 작업을 실행하거나, 시간 분할 방식으로 컨텍스트 전환을 통해 여러 스레드를 번갈아 실행

1. **운영체제 스케줄링**:
   - OS는 CPU 코어에 여러 스레드를 할당하고 **시간 분할 스케줄링(Time Slicing)**을 통해 동시에 실행되는 것처럼 보이게 합니다.
   - 각 스레드는 컨텍스트(레지스터, 프로그램 카운터 등)를 저장하고 전환하며 실행.

2. **비용이 큰 이유**:
   - 컨텍스트 전환 시 스택, 레지스터 등 많은 상태를 저장하고 복원해야 하므로 오버헤드가 큼.
   - 많은 스레드가 생성되면 메모리 사용량이 급증.

![image](https://github.com/user-attachments/assets/f139f12b-0453-4075-9860-9b1bb187a634)

- 코루틴의 처리 방식
  - 코루틴은 기본적으로 동시성, 병렬처리를 함께 진행
  - 스레드의 컨텍스트 스위칭을 별도의 çontinuation, coroutineContext로 Heap에 저장하여 사용
    - 그렇기 때문에 컨텍스트 스위칭 비용이 적음    

![image](https://github.com/user-attachments/assets/9f7de0a8-3bcc-4c92-8e2c-6055a4fd8329)

### 대규모 동시성 처리:

1. 스레드를 사용하면:
   - 1만 개의 비동기 요청을 처리하려면 1만 개의 스레드가 필요.
   - 스레드 생성 및 메모리 사용량 때문에 시스템이 과부하에 걸릴 가능성이 높음.

2. 코루틴을 사용하면:
   - 동일한 작업을 단일 스레드에서 처리 가능.
   - 각 코루틴이 가벼운 상태 머신으로 동작하므로, 메모리 소비가 최소화되고 전환 비용도 적음.

## **3. 주요 차이점**

| 특징                   | **스레드(Thread)**                                      | **코루틴(Coroutine)**                                   |
| ---------------------- | ------------------------------------------------------- | ------------------------------------------------------- |
| **관리 주체**          | 운영체제(OS)                                            | Kotlin 런타임                                           |
| **메모리 소비**        | 각 스레드가 독립적인 스택을 사용 (수백 KB~MB 단위)      | 스택 없이 상태 머신 기반 (수십 바이트)                  |
| **컨텍스트 전환 비용** | 스택, 레지스터 저장/복원 (높은 비용)                    | 상태만 저장 (낮은 비용)                                 |
| **비동기 처리**        | 차단(blocking)이 기본                                   | 비차단(non-blocking) 방식 기본                          |
| **동작 단위**          | 선점적(preemptive) - OS가 강제로 스레드 전환            | 협력적(cooperative) - 코루틴 스스로 양보 (suspend)      |
| **수량 제한**          | 스레드 수는 OS/메모리에 따라 제한됨 (보통 수천 개 이하) | 코루틴은 제한 없이 생성 가능 (수십만 개 이상 실행 가능) |

---

**정리**
- **스레드**: 운영체제가 관리하는 무거운 실행 단위로, 높은 비용을 감수해야 함.
- **코루틴**: 사용자 수준에서 관리되는 경량 실행 단위로, **협력적 스케줄링**과 **상태 머신 기반의 동작**을 통해 자원을 최적화.
- 코루틴은 많은 동시 작업을 필요로 하는 현대 애플리케이션(네트워크 처리, UI 비동기 작업 등)에 적합한 동시성 솔루션을 제공.


### 간단 실습? - 10분

- https://dong-geon.tistory.com/72
